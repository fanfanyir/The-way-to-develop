1. React Developer Tools  Chrome插件，方便调试
2. PropTypes 与 DefaultProps:   
    PropTypes: 接收外部传来的 Props时类型要做校验
    DefaultProps: 如果父组件没有向子组件传值时，可以设置默认值
    PropTypes.arrayOf(PropTypes.number,PropTypes.string)      // 是 number 或者 string
3. 当组件的 state 或者 props 发生改变的时候， render 函数就会重新执行
4. 自己实现 react 底层， state 改变 render 函数重新执行的效果，思路：
    (1) state 数据
    (2) JSX 模板
    (3) 数据 + 模板 结合，生成真实的 DOM，来显示
    (4) state 发生改变
    (5) 数据 + 模板 结合，生成真实的 DOM， 替换原始的 DOM

    缺陷： 每次都生成一个完整的 DOM，完全替换之前的 DOM-------非常耗费性能

    优化：
        (1) state 数据
        (2) JSX 模板
        (3) 数据 + 模板 结合，生成真实的 DOM，来显示
        (4) state 发生改变
        (5) 数据 + 模板 结合，生成真实的 DOM， 不直接替换原始的 DOM
        (6) 新的 DOM （文档碎片 DocumentFragment） 和原始的 DOM 作对比，找差异
        (7) 发现/找出 input 框发生了变化
        (8) 只用新的 DOM 中的 input 元素，替换掉老的 DOM 中的 input 元素

    缺陷： 
        性能的提升并不明显

    react 中结合了虚拟 DOM 的解决方案：
        (1) state 数据
        (2) JSX 模板
        (3) 数据 + 模板，生成虚拟的 DOM （虚拟 DOM 就是一个 JS 对象，用它来描述真实的 DOM）（损耗了性能，但是代价小）
            ['div',{id: 'abc'},['span',{},'hello']]

        (4) 用虚拟 DOM 的结构生成真实的 DOM，来显示
            <div id='abc'><span>hello</span></div>

        (5) state 发生变化

        (6) 数据 + 模板 生成新的虚拟 DOM （极大的提升了性能，本质上是生成一个js对象，js对象的创建的过程性能损耗极低）
            ['div',{id: 'abc'},['span',{},'bye bye']]

        (7) 比较原始虚拟 DOM  和新的虚拟 DOM 的区别，找到区别是 span 中的内容（两个 js 对象的比对，极大的提升了性能）
        
        (8) 直接操作 DOM，改变 span 中的内容
    5. <div>item</div>  =>  React.createElement('div', {}, 'item')
        // JSX -> createElement  ->  虚拟DOM(JS 对象) -> 真实的 DOM